import heapq
import random
import time
import math
import matplotlib.pyplot as plt

# Graph Generation (Adjacency List Representation)
def generate_graph(V, density=0.5):
    """ Generates a random weighted graph with V vertices and density of edges """
    graph = {i: [] for i in range(V)}
    for i in range(V):
        for j in range(i + 1, V):
            if random.random() < density:  # Add edge with given probability
                weight = random.randint(1, 100)
                graph[i].append((weight, j))
                graph[j].append((weight, i))
    return graph

# Prim's Algorithm with Binary Heap
def prim_standard(graph, V):
    """ Implements Prim's algorithm using a binary heap """
    pq = []  # Min-Heap
    visited = set()
    total_weight = 0
    
    # Start from node 0
    heapq.heappush(pq, (0, 0))  # (weight, node)
    
    while len(visited) < V:
        weight, node = heapq.heappop(pq)
        if node in visited:
            continue
        
        visited.add(node)
        total_weight += weight
        
        for edge_weight, neighbor in graph[node]:
            if neighbor not in visited:
                heapq.heappush(pq, (edge_weight, neighbor))
    
    return total_weight

# Path ORAM Simulation
class PathORAM:
    def __init__(self, N):
        """ Simulate Path ORAM with a given number of blocks N """
        self.N = N
        self.access_count = 0
    
    def access(self, block):
        """ Simulates an ORAM access, adding log(N) overhead """
        self.access_count += math.log2(self.N)
        return block

# Path ORAM Baseline Performance
def oram_baseline(oram, accesses):
    """ Measures performance of Path ORAM without Prim's algorithm """
    start_time = time.time()
    for _ in range(accesses):
        oram.access(random.randint(0, oram.N - 1))
    return time.time() - start_time, oram.access_count

# Prim's Algorithm with Path ORAM
def prim_oram(graph, V, oram):
    """ Implements Prim's algorithm with Path ORAM overhead """
    pq = []  # Min-Heap
    visited = set()
    total_weight = 0
    
    heapq.heappush(pq, (oram.access(0), 0))  # (weight, node)
    
    while len(visited) < V:
        weight, node = heapq.heappop(pq)
        if node in visited:
            continue
        
        visited.add(node)
        total_weight += oram.access(weight)
        
        for edge_weight, neighbor in graph[node]:
            if neighbor not in visited:
                heapq.heappush(pq, (oram.access(edge_weight), neighbor))
    
    return total_weight, oram.access_count

# Experiment: Measuring Performance
def experiment():
    V_values = [10, 50, 100, 200, 500]  # Different graph sizes
    density = 0.3  # Edge density
    results = []
    
    for V in V_values:
        graph = generate_graph(V, density)
        
        # Standard Prim's Algorithm
        start_time = time.time()
        standard_mst = prim_standard(graph, V)
        standard_time = time.time() - start_time
        
        # Path ORAM Baseline Performance
        N = V * (V - 1) // 2  # Approximate number of edges as memory blocks
        oram = PathORAM(N)
        baseline_time, baseline_accesses = oram_baseline(oram, N)
        
        # Prim's Algorithm with Path ORAM
        oram = PathORAM(N)
        start_time = time.time()
        oram_mst, access_count = prim_oram(graph, V, oram)
        oram_time = time.time() - start_time
        
        results.append((V, standard_time, oram_time, baseline_time, access_count, baseline_accesses))
        
        print(f"V={V}: Standard={standard_time:.4f}s, ORAM={oram_time:.4f}s, ORAM Baseline={baseline_time:.4f}s, ORAM Accesses={access_count:.2f}, ORAM Baseline Accesses={baseline_accesses:.2f}")
    
    # Plot results
    V_vals, standard_times, oram_times, baseline_times, _, _ = zip(*results)
    plt.figure(figsize=(8, 5))
    plt.plot(V_vals, standard_times, marker='o', label='Standard Prim')
    plt.plot(V_vals, oram_times, marker='s', label='Prim with ORAM')
    plt.plot(V_vals, baseline_times, marker='^', label='Path ORAM Baseline')
    plt.xlabel("Number of Nodes (V)")
    plt.ylabel("Execution Time (s)")
    plt.title("Performance Comparison: Prim's Algorithm & Path ORAM")
    plt.legend()
    plt.grid()
    plt.show()
    
    return results

# Run the experiment
experiment()
